# Property Testing Library Design for Catena: A Category Theory-Native Approach

## Core Vision and Philosophy

Catena's property testing library should leverage the language's built-in category theory concepts to create a testing framework that is both theoretically sound and practically powerful. By treating generators as first-class categorical structures and integrating shrinking through comonadic rose trees, we can build a library that naturally expresses complex test scenarios while avoiding the licensing constraints of PropEr.

## 1. Generator Architecture: Category Theory as Foundation

### 1.1 Generator Type and Monadic Structure

**Core Generator Type:**
```
Generator<A> = (Size, Seed) -> Tree<A>
```

This signature embeds three crucial design decisions:
- **Size parameter** enables gradual complexity scaling for recursive structures
- **Seed** provides deterministic reproducibility for debugging
- **Tree<A>** (rose tree) integrates shrinking directly into generation

**Categorical Structure:**
- **Functor**: Transform generated values while preserving generation strategy
- **Applicative**: Combine independent generators in parallel without data dependencies  
- **Monad**: Enable dependent generation where later values depend on earlier ones

The monadic structure is essential for QuickCheck-style generation but comes with a trade-off: dependent generators (using the monad interface) have suboptimal default shrinking. Catena should expose both applicative and monadic interfaces, documenting when each is appropriate.

### 1.2 Integrated Shrinking via Comonads

**The Hedgehog Innovation** adapted for BEAM:

Modern property testing has moved decisively toward **integrated shrinking** where the shrink tree is generated alongside the value. This approach, inspired by comonadic structures, solves the critical problem of shrinking violating generator invariants.

**Rose Tree Structure:**
```
data Tree<A> = Tree {
  value: A,              -- Current value
  children: List<Tree<A>> -- Possible shrinks
}
```

**Comonadic Operations:**
- `extract`: Get the current value from the tree
- `duplicate`: Create a tree of all subtrees (for shrinking exploration)
- `extend`: Apply context-aware transformations across the tree

**Key Advantage:** When you map, filter, or compose generators, shrinking automatically respects those transformations. If you generate even numbers with `map((*2), gen_int(range(0, 50)))`, the shrinks are automatically even numbers too.

**Important Caveat:** While integrated shrinking eliminates many bugs, **dependent generators still require careful thought**. When using monadic bind, shrinking the first component doesn't automatically re-shrink dependent components. For complex dependent generation, explicit tree manipulation may be needed.

### 1.3 Generator Combinators

**Primitive Combinators:**
- `constant(value)`: Always generate the same value (pure/return)
- `choose(range)`: Random selection within a range
- `element(list)`: Pick from a list uniformly
- `frequency(weighted_list)`: Weighted random choice

**Compositional Combinators:**
- `map(f, gen)`: Functor - transform generated values
- `apply(gen_f, gen_a)`: Applicative - combine independent generators
- `bind(gen, f)`: Monad - dependent generation
- `filter(pred, gen)`: Constrained generation (use sparingly)

**Structural Combinators:**
- `list(gen, range)`: Generate lists with size in range
- `tuple(gen1, gen2, ...)`: Product types
- `one_of(gens)`: Sum types
- `recursive(base, recursive)`: For tree-like structures

**Range Combinators** (Hedgehog innovation):
```
Range.linear(min, max)      -- Linear distribution
Range.constant(n)            -- Fixed size
Range.exponential(min, max)  -- Exponential growth
```

Ranges provide first-class control over generation scope, making tests more predictable and shrinking more effective.

## 2. Law Testing: Verifying Categorical Properties

### 2.1 Three-Tier Architecture

Catena's built-in category theory traits (Mapper/Functor, Pipeline/Monad, Applicator/Applicative) should have automatic law testing support:

**Tier 1: Law Specifications** (Pure trait definitions)
```
module CatenaLaws.Functor do
  # Identity law: map(id, x) == x
  def identity_law(gen, equal?) do
    property "functor identity" do
      forall x <- gen do
        Mapper.map(x, &Function.identity/1) |> equal?.(x)
      end
    end
  end
  
  # Composition law: map(f . g) == map(f) . map(g)
  def composition_law(gen, fun_gen, equal?) do
    property "functor composition" do
      forall {x, f, g} <- {gen, fun_gen, fun_gen} do
        composed = fn v -> g.(f.(v)) end
        left = Mapper.map(x, composed)
        right = x |> Mapper.map(f) |> Mapper.map(g)
        equal?.(left, right)
      end
    end
  end
end
```

**Tier 2: Discipline Framework** (Test suite packaging)
```
module CatenaLaws.Suite do
  def functor_laws(type_module, gen, equal?) do
    [
      CatenaLaws.Functor.identity_law(gen, equal?),
      CatenaLaws.Functor.composition_law(gen, gen_function(), equal?)
    ]
  end
  
  def monad_laws(type_module, gen, equal?) do
    functor_laws(type_module, gen, equal?) ++
    [
      CatenaLaws.Monad.left_identity_law(...),
      CatenaLaws.Monad.right_identity_law(...),
      CatenaLaws.Monad.associativity_law(...)
    ]
  end
end
```

**Tier 3: Test Integration**
```
defmodule MyList.Test do
  use CatenaTest
  
  # Macro generates all law tests automatically
  verify_laws MyList, :mapper, gen: gen_list(gen_int())
  verify_laws MyList, :pipeline, gen: gen_list(gen_int())
end
```

### 2.2 Automatic Law Derivation

When a type implements a trait, automatically generate law tests:

```
defmodule Tree do
  @behaviour Mapper
  
  # Single line triggers automatic law verification
  derive_law_tests for: [Mapper, Applicator, Pipeline]
  
  def map(tree, f), do: # implementation
end
```

The compiler/macro system should:
1. Detect trait implementation
2. Check for `derive_law_tests` directive
3. Generate test module with property tests for each law
4. Require generators to be defined (or use generic derivation)

### 2.3 Generic Generator Derivation

For simple algebraic data types, automatically derive generators:

```
defmodule Person do
  @derive Generator
  defstruct [:name, :age, :email]
end

# Compiler generates:
gen_person() = 
  apply(
    fn n, a, e -> %Person{name: n, age: a, email: e} end,
    gen_string(),
    gen_int(range(0, 120)),
    gen_email()
  )
```

**Derivation Strategy:**
- Product types (structs): Use applicative composition
- Sum types (unions): Use `one_of` combinator  
- Recursive types: Use `sized` and `recursive` combinators
- Respect type constraints where specified

## 3. BEAM-Specific Features

### 3.1 Process and Concurrency Testing

The BEAM VM's actor model requires specialized testing support:

**Stateful Property Testing:**
```
defmodule GenServerTest do
  use CatenaStateMachine
  
  state_machine MyGenServer do
    # Initial state
    initial_state do
      %{counter: 0, history: []}
    end
    
    # Commands with preconditions
    command :increment do
      args { gen_int(range(1, 10)) }
      
      precondition state, [amount] do
        state.counter + amount < 1000
      end
      
      execute pid, [amount] do
        GenServer.call(pid, {:increment, amount})
      end
      
      next_state state, [amount], _result do
        %{state | 
          counter: state.counter + amount,
          history: [{:increment, amount} | state.history]
        }
      end
      
      postcondition state, [amount], result do
        result == state.counter + amount
      end
    end
  end
end
```

**Parallel Execution Testing:**
```
property "concurrent operations are linearizable" do
  forall_parallel {initial_ops, parallel_ops} <- 
    {command_list(), parallel_command_list()} do
    
    # Execute initial operations sequentially
    state = execute_sequential(initial_ops)
    
    # Execute parallel operations concurrently
    results = execute_parallel(parallel_ops)
    
    # Verify there exists some sequential ordering that explains results
    exists_linearization?(state, parallel_ops, results)
  end
end
```

### 3.2 Message Passing Properties

```
property "all sent messages are eventually received" do
  forall {messages, delivery_strategy} <- 
    {list(gen_message()), gen_delivery_strategy()} do
    
    receiver = spawn_receiver()
    
    Enum.each(messages, fn msg ->
      send(receiver, msg, delivery_strategy)
    end)
    
    # Wait with timeout
    received = collect_messages(receiver, timeout: 5000)
    
    messages_match?(messages, received)
  end
end
```

### 3.3 Distribution Testing

```
property "distributed counter remains consistent" do
  forall operations <- command_list() do
    nodes = [:node1, :node2, :node3]
    
    # Start distributed counter on each node
    Enum.each(nodes, &start_counter/1)
    
    # Execute operations on random nodes
    execute_distributed(operations, nodes)
    
    # Check eventual consistency
    eventually_consistent?(nodes, timeout: 10_000)
  end
end
```

## 4. Advanced Features

### 4.1 Metamorphic Testing Support

For systems where oracles are difficult (ML models, compilers, scientific computing):

```
property "metamorphic relation: compression then decompression" do
  forall data <- gen_binary() do
    compressed = compress(data)
    decompressed = decompress(compressed)
    
    # Metamorphic relation
    decompressed == data
  end
end

property "metamorphic: order invariance" do
  forall items <- list(gen_item()) do
    shuffled = Enum.shuffle(items)
    
    # Result should be invariant to input order
    process(items) == process(shuffled)
  end
end
```

### 4.2 Coverage-Guided Generation

For properties with sparse preconditions, integrate coverage tracking:

```
property "parser handles complex expressions", coverage_guided: true do
  forall ast <- gen_ast() do
    is_valid(ast) ==> begin
      # Coverage tracking helps generate more valid ASTs over time
      parsed = parse(unparse(ast))
      parsed == ast
    end
  end
end
```

**Implementation:** Track which branches/paths are explored, bias future generation toward unexplored areas.

### 4.3 Type-Directed Properties

Leverage Catena's type system to automatically generate properties:

```
# From type specification, auto-generate roundtrip property
@spec encode(term()) :: binary()
@spec decode(binary()) :: {:ok, term()} | :error

# Automatically generates:
property "encode/decode roundtrip" do
  forall value <- gen_term() do
    encoded = encode(value)
    {:ok, decoded} = decode(encoded)
    decoded == value
  end
end
```

### 4.4 State Machine DSL

For complex stateful systems:

```
defmodule FileSystemTest do
  use CatenaStateMachine
  
  state_machine FileSystem do
    command :create_file do
      args { {gen_path(), gen_content()} }
      requires { |state, [path, _]| not Map.has_key?(state.files, path) }
      updates { |state, [path, content]| put_in(state.files[path], content) }
    end
    
    command :read_file do
      args { gen_existing_path() }
      requires { |state, [path]| Map.has_key?(state.files, path) }
      ensures { |state, [path], result| result == state.files[path] }
    end
    
    invariant "no orphaned file descriptors" do
      |state| length(state.open_fds) <= state.max_fds
    end
  end
end
```

## 5. Licensing Strategy

**Recommended: BSD-3-Clause or MIT**

Given PropEr's GPL v3 license creates friction for commercial use, Catena's property testing library should use a permissive license:

**Advantages:**
- Maximum adoption in commercial environments
- No copyleft concerns
- Can reference algorithms from Hedgehog (BSD-3) and fast-check (MIT)
- Aligns with Erlang/OTP's Apache 2.0 license

**Clean Room Implementation:**
- Study algorithms from open implementations (Hedgehog, fast-check, Hypothesis)
- Implement from understanding, not copying code
- Document algorithmic inspirations
- Avoid any GPL/LGPL code dependencies

## 6. Implementation Roadmap

### Phase 1: Core Generators (Weeks 1-4)
- Implement basic generator type with rose tree structure
- Functor, Applicative, Monad instances
- Primitive combinators (constant, choose, element)
- Range types and range-based generation
- Basic shrinking infrastructure

### Phase 2: Standard Generators (Weeks 5-6)
- Generators for built-in types (integers, floats, atoms, strings, binaries)
- Collection generators (lists, tuples, maps)
- Recursive structure support
- Function generators (using seed variation)

### Phase 3: Property Testing Framework (Weeks 7-10)
- Property specification DSL
- Test runner integration
- Failure reporting and shrinking
- Counterexample minimization
- Seed-based reproducibility

### Phase 4: Law Testing (Weeks 11-14)
- Law specifications for each trait (Mapper, Pipeline, Applicator, etc.)
- Discipline-style test suite packaging
- `derive_law_tests` macro
- Integration with test framework
- Documentation and examples

### Phase 5: Stateful Testing (Weeks 15-18)
- State machine specification DSL
- Command generation and execution
- Symbolic vs. concrete execution phases
- Parallel execution support
- Linearizability checking

### Phase 6: BEAM Integration (Weeks 19-22)
- Process testing support
- Message passing properties
- Concurrency testing utilities
- Distribution testing helpers
- OTP behavior testing patterns

### Phase 7: Advanced Features (Weeks 23-26)
- Generic generator derivation
- Coverage-guided generation
- Metamorphic testing support
- Type-directed property generation
- Performance optimization

## 7. API Design Examples

### 7.1 Basic Property Testing

```
defmodule StringTest do
  use CatenaTest
  
  property "reverse twice is identity" do
    forall str <- gen_string() do
      str |> String.reverse() |> String.reverse() == str
    end
  end
  
  property "length is preserved by reverse" do
    forall str <- gen_string(range: Range.linear(0, 100)) do
      String.length(str) == String.length(String.reverse(str))
    end
  end
end
```

### 7.2 Custom Generators

```
def gen_email do
  map3(
    &("#{&1}@#{&2}.#{&3}"),
    gen_string(charset: :alphanumeric, range: Range.linear(1, 20)),
    gen_string(charset: :alphanumeric, range: Range.linear(3, 15)),
    element(["com", "org", "net", "edu"])
  )
end

def gen_sorted_list(elem_gen) do
  bind(list(elem_gen), fn list ->
    constant(Enum.sort(list))
  end)
end
```

### 7.3 Dependent Generation

```
property "generated lists match their claimed length" do
  forall length <- gen_int(range(0, 100)) do
    forall list <- list(gen_int(), range: Range.constant(length)) do
      length(list) == length
    end
  end
end

# Better with monadic bind:
property "generated lists match their claimed length" do
  forall {length, list} <- begin
    bind(gen_int(range(0, 100)), fn len ->
      map(list(gen_int(), range: Range.constant(len)), fn lst ->
        {len, lst}
      end)
    end)
  end do
    length(list) == length
  end
end
```

### 7.4 Law Testing Integration

```
defmodule MyMaybe do
  @behaviour Mapper
  @behaviour Pipeline
  
  # Automatically generates test suite testing all laws
  derive_law_tests for: [Mapper, Pipeline]
  
  # Need to specify how to generate values and test equality
  defimpl CatenaTest.Generator do
    def arbitrary(_type) do
      one_of([
        map(gen_int(), &{:just, &1}),
        constant(:nothing)
      ])
    end
  end
  
  defimpl CatenaTest.Equality do
    def equal?({:just, a}, {:just, b}), do: a == b
    def equal?(:nothing, :nothing), do: true
    def equal?(_, _), do: false
  end
end
```

## 8. Key Design Decisions Summary

### ✅ Use Integrated Shrinking
**Rationale:** Eliminates entire class of bugs where shrinking violates invariants. This is the single most important innovation in modern property testing.

**Implementation:** Rose trees generated alongside values, with comonadic operations for exploration.

### ✅ Explicit Generators (Not Protocols)
**Rationale:** Type classes/protocols for generation create global state issues and make cross-framework interoperability harder. Explicit generator values are more flexible.

**Implementation:** Generators are first-class values that can be passed, composed, and transformed.

### ✅ Both Applicative and Monadic Interfaces
**Rationale:** Applicative is better for independent generation (parallel, composable), but Monad is necessary for dependent generation.

**Implementation:** Expose both, document trade-offs, encourage applicative when possible.

### ✅ First-Class Range Types
**Rationale:** Ranges make generation more predictable and testable. They're especially important for BEAM where resource limits matter.

**Implementation:** `Range` module with `linear`, `constant`, `exponential` constructors.

### ✅ Built-in Law Testing
**Rationale:** Catena has category theory built-in, so law testing should be first-class, not bolted on.

**Implementation:** Three-tier architecture (laws, discipline, integration) with macro-based derivation.

### ✅ State Machine Testing for OTP
**Rationale:** BEAM's killer feature is OTP, and OTP is fundamentally stateful. Testing stateful systems must be ergonomic.

**Implementation:** DSL for specifying state machines with commands, pre/post-conditions, and invariants.

### ✅ Permissive Licensing (BSD-3/MIT)
**Rationale:** PropEr's GPL v3 creates friction. Permissive license maximizes adoption.

**Implementation:** Clean room implementation drawing on permissively-licensed sources (Hedgehog, fast-check, Hypothesis).

## 9. Success Metrics

The library should be considered successful when:

1. **Law testing is automatic**: Adding a trait implementation automatically triggers law tests
2. **Shrinking just works**: Developers rarely need to think about shrinking explicitly
3. **OTP testing is natural**: State machine testing feels like writing OTP behaviors
4. **Adoption in critical systems**: Used for testing production BEAM applications
5. **Zero licensing complaints**: No corporate policies block adoption
6. **Educational value**: Helps developers understand category theory through testing
7. **Performance acceptable**: Property tests complete in CI/CD within reasonable time (50ms-30s per suite)

## 10. Theoretical Soundness with Practical Usability

The design balances theoretical rigor with pragmatic needs:

**Theoretically Sound:**
- Generators respect functor/applicative/monad laws
- Shrinking is comonadic (via rose trees)
- Natural transformations enable framework interoperability
- Law testing verifies categorical properties

**Practically Useful:**
- Clear error messages when properties fail
- Integrated shrinking minimizes counterexamples automatically
- State machine DSL maps to OTP patterns developers know
- Coverage guidance helps with sparse preconditions
- Performance acceptable for CI/CD pipelines

**The synthesis:** Category theory provides the **architecture**, but developer ergonomics drive the **API design**. The mathematics ensures correctness by construction, while practical features (ranges, state machines, BEAM integration) ensure the library solves real problems.

This design creates a property testing library that is both a showcase for category theory's practical benefits and a powerful tool for building reliable BEAM applications.
