-- Catena Standard Library Prelude
-- Core traits and types that form the foundation of Catena
--
-- This module defines the category theory abstractions using pragmatic names:
-- - Comparable (Setoid) - Types with equality
-- - Combiner (Semigroup) - Associative binary operation
-- - Accumulator (Monoid) - Combiner with identity
-- - Mapper (Functor) - Structure-preserving transformations
-- - Applicator (Applicative) - Mapper with pure and apply
-- - Chainable (Chain) - Sequential binding
-- - Pipeline (Monad) - Composable effectful computations
-- - Extractor (Comonad) - Extract values from context

module Prelude

export trait Comparable
export trait Orderable
export trait Combiner
export trait Accumulator
export trait Mapper
export trait Applicator
export trait Chainable
export trait Pipeline
export trait Extractor
export trait Traversable
export trait Foldable

-- Comparable: Types with equality testing
-- Laws:
--   reflexivity: x === x
--   symmetry: x === y implies y === x
--   transitivity: x === y and y === z implies x === z
trait Comparable a {
  equals : a -> a -> Bool

  notEquals : a -> a -> Bool
  notEquals x y = match equals x y
    | true -> false
    | false -> true
  end
}

-- Orderable: Types with ordering
-- Laws:
--   antisymmetry: x <= y and y <= x implies x === y
--   transitivity: x <= y and y <= z implies x <= z
--   totality: x <= y or y <= x
trait Orderable a : Comparable a {
  compare : a -> a -> Ordering

  lessThan : a -> a -> Bool
  lessThan x y = match compare x y
    | LT -> true
    | _ -> false
  end

  lessOrEqual : a -> a -> Bool
  lessOrEqual x y = match compare x y
    | GT -> false
    | _ -> true
  end

  greaterThan : a -> a -> Bool
  greaterThan x y = match compare x y
    | GT -> true
    | _ -> false
  end

  greaterOrEqual : a -> a -> Bool
  greaterOrEqual x y = match compare x y
    | LT -> false
    | _ -> true
  end
}

-- Combiner: Types with associative binary operation
-- Laws:
--   associativity: combine (combine x y) z === combine x (combine y z)
trait Combiner a {
  combine : a -> a -> a
}

-- Accumulator: Combiner with identity element
-- Laws:
--   left identity: combine empty x === x
--   right identity: combine x empty === x
trait Accumulator a : Combiner a {
  empty : a
}

-- Mapper: Structure-preserving transformations (Functor)
-- Laws:
--   identity: map id x === x
--   composition: map (f . g) x === map f (map g x)
trait Mapper f {
  map : (a -> b) -> f a -> f b
}

-- Applicator: Mapper with pure and apply (Applicative)
-- Laws:
--   identity: apply (pure id) x === x
--   composition: apply (apply (apply (pure compose) f) g) x === apply f (apply g x)
--   homomorphism: apply (pure f) (pure x) === pure (f x)
--   interchange: apply f (pure x) === apply (pure (fn g -> g x)) f
trait Applicator f : Mapper f {
  pure : a -> f a
  apply : f (a -> b) -> f a -> f b
}

-- Chainable: Sequential binding (Chain)
-- Laws:
--   associativity: chain g (chain f x) === chain (fn a -> chain g (f a)) x
trait Chainable m : Mapper m {
  chain : (a -> m b) -> m a -> m b
}

-- Pipeline: Composable effectful computations (Monad)
-- Laws:
--   left identity: chain f (pure x) === f x
--   right identity: chain pure x === x
--   associativity: chain g (chain f x) === chain (fn a -> chain g (f a)) x
trait Pipeline m : Applicator m, Chainable m {
  -- Derived operations
  join : m (m a) -> m a
  join x = chain id x

  sequence : List (m a) -> m (List a)
  sequence xs = match xs
    | [] -> pure []
    | h :: t -> chain (fn x -> map (fn rest -> x :: rest) (sequence t)) h
  end
}

-- Extractor: Extract values from context (Comonad)
-- Laws:
--   left identity: extend extract x === x
--   right identity: extract (extend f x) === f x
--   associativity: extend f (extend g x) === extend (fn w -> f (extend g w)) x
trait Extractor w : Mapper w {
  extract : w a -> a
  extend : (w a -> b) -> w a -> w b

  duplicate : w a -> w (w a)
  duplicate x = extend id x
}

-- Foldable: Types that can be folded to a value
trait Foldable t {
  foldRight : (a -> b -> b) -> b -> t a -> b
  foldLeft : (b -> a -> b) -> b -> t a -> b

  toList : t a -> List a
  toList x = foldRight (fn a rest -> a :: rest) [] x
}

-- Traversable: Types that can be traversed with effects
trait Traversable t : Mapper t, Foldable t {
  traverse : Applicator f => (a -> f b) -> t a -> f (t b)

  sequenceA : Applicator f => t (f a) -> f (t a)
  sequenceA x = traverse id x
}

-- Core type definitions
type Ordering = LT | EQ | GT

type Maybe a = None | Some a

type Either a b = Left a | Right b

type Result a e = Ok a | Err e

-- Instances for Maybe
instance Mapper Maybe where
  map f x = match x
    | None -> None
    | Some a -> Some (f a)
  end
}

instance Applicator Maybe {
  pure x = Some x

  apply mf mx = match mf
    | None -> None
    | Some f -> map f mx
  end
}

instance Chainable Maybe {
  chain f x = match x
    | None -> None
    | Some a -> f a
  end
}

instance Pipeline Maybe {}

instance Comparable a => Comparable (Maybe a) {
  equals x y = match x, y
    | None, None -> true
    | Some a, Some b -> equals a b
    | _, _ -> false
  end
}

-- Instances for Either
instance Mapper (Either e) {
  map f x = match x
    | Left e -> Left e
    | Right a -> Right (f a)
  end
}

instance Applicator (Either e) {
  pure x = Right x

  apply ef ex = match ef
    | Left e -> Left e
    | Right f -> map f ex
  end
}

instance Chainable (Either e) {
  chain f x = match x
    | Left e -> Left e
    | Right a -> f a
  end
}

instance Pipeline (Either e) {}

-- Instances for List
instance Mapper List {
  map f xs = match xs
    | [] -> []
    | h :: t -> f h :: map f t
  end
}

instance Applicator List {
  pure x = [x]

  apply fs xs = match fs
    | [] -> []
    | f :: rest -> map f xs ++ apply rest xs
  end
}

instance Chainable List {
  chain f xs = match xs
    | [] -> []
    | h :: t -> f h ++ chain f t
  end
}

instance Pipeline List {}

instance Foldable List {
  foldRight f z xs = match xs
    | [] -> z
    | h :: t -> f h (foldRight f z t)
  end

  foldLeft f z xs = match xs
    | [] -> z
    | h :: t -> foldLeft f (f z h) t
  end
}

instance Comparable a => Comparable (List a) {
  equals xs ys = match xs, ys
    | [], [] -> true
    | h1 :: t1, h2 :: t2 -> equals h1 h2 && equals t1 t2
    | _, _ -> false
  end
}

instance Combiner (List a) {
  combine xs ys = xs ++ ys
}

instance Accumulator (List a) {
  empty = []
}
