-- Catena Standard Library Prelude
-- Core traits and types that form the foundation of Catena
--
-- This module defines the category theory abstractions using pragmatic names:
-- - Comparable (Setoid) - Types with equality
-- - Combiner (Semigroup) - Associative binary operation
-- - Accumulator (Monoid) - Combiner with identity
-- - Mapper (Functor) - Structure-preserving transformations
-- - Applicator (Applicative) - Mapper with pure and apply
-- - Chainable (Chain) - Sequential binding
-- - Pipeline (Monad) - Composable effectful computations
-- - Extractor (Comonad) - Extract values from context

module Prelude

export trait Comparable
export trait Orderable
export trait Combiner
export trait Accumulator
export trait Mapper
export trait Applicator
export trait Chainable
export trait Pipeline
export trait Extractor
export trait Traversable
export trait Foldable

-- Comparable: Types with equality testing
-- Laws:
--   reflexivity: x === x
--   symmetry: x === y implies y === x
--   transitivity: x === y and y === z implies x === z
trait Comparable a where
  equals : a -> a -> Bool,

  notEquals : a -> a -> Bool,
  notEquals x y = match (equals x y) of
    | true -> false
    | false -> true
  end
end

-- Orderable: Types with ordering
-- Laws:
--   antisymmetry: x <= y and y <= x implies x === y
--   transitivity: x <= y and y <= z implies x <= z
--   totality: x <= y or y <= x
trait Orderable a extend Comparable a where
  compare : a -> a -> Ordering,

  lessThan : a -> a -> Bool,
  lessThan x y = match (compare x y) of
    | LT -> true
    | _ -> false
  end,

  lessOrEqual : a -> a -> Bool,
  lessOrEqual x y = match (compare x y) of
    | GT -> false
    | _ -> true
  end,

  greaterThan : a -> a -> Bool,
  greaterThan x y = match (compare x y) of
    | GT -> true
    | _ -> false
  end,

  greaterOrEqual : a -> a -> Bool,
  greaterOrEqual x y = match (compare x y) of
    | LT -> false
    | _ -> true
  end
end

-- Combiner: Types with associative binary operation
-- Laws:
--   associativity: combine (combine x y) z === combine x (combine y z)
trait Combiner a where
  combine : a -> a -> a
end

-- Accumulator: Combiner with identity element
-- Laws:
--   left identity: combine empty x === x
--   right identity: combine x empty === x
trait Accumulator a extend Combiner a where
  empty : a
end

-- Mapper: Structure-preserving transformations (Functor)
-- Laws:
--   identity: map id x === x
--   composition: map (f . g) x === map f (map g x)
trait Mapper f where
  map : (a -> b) -> f a -> f b
end

-- Applicator: Mapper with pure and apply (Applicative)
-- Laws:
--   identity: apply (pure id) x === x
--   composition: apply (apply (apply (pure compose) f) g) x === apply f (apply g x)
--   homomorphism: apply (pure f) (pure x) === pure (f x)
--   interchange: apply f (pure x) === apply (pure (fn g -> g x)) f
trait Applicator f extend Mapper f where
  pure : a -> f a,
  apply : f (a -> b) -> f a -> f b
end

-- Chainable: Sequential binding (Chain)
-- Laws:
--   associativity: chain g (chain f x) === chain (fn a -> chain g (f a)) x
trait Chainable m extend Mapper m where
  chain : (a -> m b) -> m a -> m b
end

-- Pipeline: Composable effectful computations (Monad)
-- Laws:
--   left identity: chain f (pure x) === f x
--   right identity: chain pure x === x
--   associativity: chain g (chain f x) === chain (fn a -> chain g (f a)) x
trait Pipeline m extend Applicator m, Chainable m where
  -- Derived operations
  join : m (m a) -> m a,
  join x = chain id x,

  sequence : List (m a) -> m (List a),
  sequence xs = match xs of
    | [] -> pure []
    | h :: t -> chain (fn x -> map (fn rest -> x :: rest) (sequence t)) h
  end
end

-- Extractor: Extract values from context (Comonad)
-- Laws:
--   left identity: coflatMap extract x === x
--   right identity: extract (coflatMap f x) === f x
--   associativity: coflatMap f (coflatMap g x) === coflatMap (fn w -> f (coflatMap g w)) x
trait Extractor w extend Mapper w where
  extract : w a -> a,
  coflatMap : (w a -> b) -> w a -> w b,

  duplicate : w a -> w (w a),
  duplicate x = coflatMap id x
end

-- Foldable: Types that can be folded to a value
trait Foldable t where
  foldRight : (a -> b -> b) -> b -> t a -> b,
  foldLeft : (b -> a -> b) -> b -> t a -> b
end

-- Traversable: Types that can be traversed with effects
trait Traversable t extend Mapper t, Foldable t where
  traverse : (a -> f b) -> t a -> f (t b) constrain Applicator f,

  sequenceA : t (f a) -> f (t a) constrain Applicator f,
  sequenceA x = traverse id x
end

-- Core type definitions
type Ordering = LT | EQ | GT

type Maybe a = None | Some a

type Either a b = Left a | Right b

type Result a e = Ok a | Err e

-- Instances for Maybe
instance Mapper Maybe where
  transform map f x = match x of
    | None -> None
    | Some a -> Some (f a)
  end
end

instance Applicator Maybe where
  transform pure x = Some x,

  transform apply mf mx = match mf of
    | None -> None
    | Some f -> map f mx
  end
end

instance Chainable Maybe where
  transform chain f x = match x of
    | None -> None
    | Some a -> f a
  end
end

instance Pipeline Maybe where
end

instance Comparable a => Comparable (Maybe a) where
  transform equals x y = match (x, y) of
    | (None, None) -> true
    | (Some a, Some b) -> equals a b
    | (_, _) -> false
  end
end

-- Instances for Either
instance Mapper (Either e) where
  transform map f x = match x of
    | Left e -> Left e
    | Right a -> Right (f a)
  end
end

instance Applicator (Either e) where
  transform pure x = Right x,

  transform apply ef ex = match ef of
    | Left e -> Left e
    | Right f -> map f ex
  end
end

instance Chainable (Either e) where
  transform chain f x = match x of
    | Left e -> Left e
    | Right a -> f a
  end
end

instance Pipeline (Either e) where
end

-- Instances for List
instance Mapper List where
  transform map f xs = match xs of
    | [] -> []
    | h :: t -> f h :: map f t
  end
end

instance Applicator List where
  transform pure x = [x],

  transform apply fs xs = match fs of
    | [] -> []
    | f :: rest -> map f xs ++ apply rest xs
  end
end

instance Chainable List where
  transform chain f xs = match xs of
    | [] -> []
    | h :: t -> f h ++ chain f t
  end
end

instance Pipeline List where
end

instance Foldable List where
  transform foldRight f z xs = match xs of
    | [] -> z
    | h :: t -> f h (foldRight f z t)
  end,

  transform foldLeft f z xs = match xs of
    | [] -> z
    | h :: t -> foldLeft f (f z h) t
  end
end

instance Comparable a => Comparable (List a) where
  transform equals xs ys = match (xs, ys) of
    | ([], []) -> true
    | (h1 :: t1, h2 :: t2) -> equals h1 h2 && equals t1 t2
    | (_, _) -> false
  end
end

instance Combiner (List a) where
  transform combine xs ys = xs ++ ys
end

instance Accumulator (List a) where
  transform empty = []
end
